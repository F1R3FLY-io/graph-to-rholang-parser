/* File generated by the BNF Converter (bnfc 2.9.6.1). */

#pragma once

/* C++ Abstract Syntax Interface.*/

/********************   TypeDef Section    ********************/

typedef int Integer;
typedef char Char;
typedef double Double;
typedef char *String;
typedef char *Ident;
typedef char *UVar;
typedef char *LVar;

/********************   Forward Declarations    ***********************/
struct Graph_;
typedef struct Graph_ *Graph;

struct Binding_;
typedef struct Binding_ *Binding;

struct GraphBinding_;
typedef struct GraphBinding_ *GraphBinding;

struct AttrVal_;
typedef struct AttrVal_ *AttrVal;

struct AttrName_;
typedef struct AttrName_ *AttrName;

struct Attr_;
typedef struct Attr_ *Attr;

struct ListAttr_;
typedef struct ListAttr_ *ListAttr;

struct Vertex_;
typedef struct Vertex_ *Vertex;

struct Name_;
typedef struct Name_ *Name;

struct ListName_;
typedef struct ListName_ *ListName;

/********************   Abstract Syntax Classes    ********************/

struct Graph_
{
  enum
  {
    is_GNil,
    is_GVertex,
    is_GVar,
    is_GNominate,
    is_GEdgeAnon,
    is_GEdgeNamed,
    is_GRuleAnon,
    is_GRuleNamed,
    is_GSubgraph,
    is_GTensor
  } kind;
  union
  {
    struct
    {
      Graph graph_;
      Vertex vertex_;
    } gVertex_;
    struct
    {
      Graph graph_;
      LVar lvar_;
    } gVar_;
    struct
    {
      Binding binding_;
    } gNominate_;
    struct
    {
      Binding binding_1, binding_2;
    } gEdgeAnon_;
    struct
    {
      Binding binding_1, binding_2;
      Name name_;
    } gEdgeNamed_;
    struct
    {
      Graph graph_1, graph_2;
    } gRuleAnon_;
    struct
    {
      Graph graph_1, graph_2;
      Name name_;
    } gRuleNamed_;
    struct
    {
      GraphBinding graphbinding_;
    } gSubgraph_;
    struct
    {
      Graph graph_1, graph_2;
    } gTensor_;
  } u;
};

Graph make_GNil(void);
Graph make_GVertex(Vertex p0, Graph p1);
Graph make_GVar(LVar p0, Graph p1);
Graph make_GNominate(Binding p0);
Graph make_GEdgeAnon(Binding p0, Binding p1);
Graph make_GEdgeNamed(Name p0, Binding p1, Binding p2);
Graph make_GRuleAnon(Graph p0, Graph p1);
Graph make_GRuleNamed(Name p0, Graph p1, Graph p2);
Graph make_GSubgraph(GraphBinding p0);
Graph make_GTensor(Graph p0, Graph p1);

struct Binding_
{
  enum
  {
    is_VBind
  } kind;
  union
  {
    struct
    {
      Graph graph_;
      LVar lvar_;
      Vertex vertex_;
    } vBind_;
  } u;
};

Binding make_VBind(LVar p0, Vertex p1, Graph p2);

struct GraphBinding_
{
  enum
  {
    is_GBind
  } kind;
  union
  {
    struct
    {
      Graph graph_1, graph_2;
      UVar uvar_;
    } gBind_;
  } u;
};

GraphBinding make_GBind(UVar p0, Graph p1, Graph p2);

struct AttrVal_
{
  enum
  {
    is_AttributeValue
  } kind;
  union
  {
    struct
    {
      LVar lvar_;
    } attributeValue_;
  } u;
};

AttrVal make_AttributeValue(LVar p0);

struct AttrName_
{
  enum
  {
    is_AttributeName
  } kind;
  union
  {
    struct
    {
      LVar lvar_;
    } attributeName_;
  } u;
};

AttrName make_AttributeName(LVar p0);

struct Attr_
{
  enum
  {
    is_AttributePair
  } kind;
  union
  {
    struct
    {
      AttrName attrname_;
      AttrVal attrval_;
    } attributePair_;
  } u;
};

Attr make_AttributePair(AttrName p0, AttrVal p1);

struct ListAttr_
{
  enum
  {
    is_EmptyAttrList,
    is_AttrList
  } kind;
  union
  {
    struct
    {
      Attr attr_;
      ListAttr listattr_;
    } attrList_;
  } u;
};

ListAttr make_EmptyAttrList(void);
ListAttr make_AttrList(Attr p0, ListAttr p1);

struct Vertex_
{
  enum
  {
    is_VName
  } kind;
  union
  {
    struct
    {
      Name name_;
    } vName_;
  } u;
};

Vertex make_VName(Name p0);

struct Name_
{
  enum
  {
    is_NameWildcard,
    is_NameVVar,
    is_NameGVar,
    is_NameQuoteGraph,
    is_NameQuoteVertex
  } kind;
  union
  {
    struct
    {
      LVar lvar_;
    } nameVVar_;
    struct
    {
      UVar uvar_;
    } nameGVar_;
    struct
    {
      Graph graph_;
    } nameQuoteGraph_;
    struct
    {
      Vertex vertex_;
    } nameQuoteVertex_;
  } u;
};

Name make_NameWildcard(void);
Name make_NameVVar(LVar p0);
Name make_NameGVar(UVar p0);
Name make_NameQuoteGraph(Graph p0);
Name make_NameQuoteVertex(Vertex p0);

struct ListName_
{
  Name name_;
  ListName listname_;
};

ListName make_ListName(Name p1, ListName p2);

/***************************   Cloning   ******************************/

Graph clone_Graph(Graph p);
Binding clone_Binding(Binding p);
GraphBinding clone_GraphBinding(GraphBinding p);
AttrVal clone_AttrVal(AttrVal p);
AttrName clone_AttrName(AttrName p);
Attr clone_Attr(Attr p);
ListAttr clone_ListAttr(ListAttr p);
Vertex clone_Vertex(Vertex p);
Name clone_Name(Name p);
ListName clone_ListName(ListName p);

/********************   Recursive Destructors    **********************/

/* These free an entire abstract syntax tree
 * including all subtrees and strings.
 *
 * Will not work properly if there is sharing in the tree,
 * i.e., when some pointers are aliased.  In this case
 * it will attempt to free the same memory twice.
 */

void free_Graph(Graph p);
void free_Binding(Binding p);
void free_GraphBinding(GraphBinding p);
void free_AttrVal(AttrVal p);
void free_AttrName(AttrName p);
void free_Attr(Attr p);
void free_ListAttr(ListAttr p);
void free_Vertex(Vertex p);
void free_Name(Name p);
void free_ListName(ListName p);
