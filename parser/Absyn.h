/* File generated by the BNF Converter (bnfc 2.9.6.1). */

#ifndef ABSYN_HEADER
#define ABSYN_HEADER

/* strdup was not in the ISO C standard before 6/2019 (C2x), but in POSIX 1003.1.
 * See: https://en.cppreference.com/w/c/experimental/dynamic/strdup
 * Setting _POSIX_C_SOURCE to 200809L activates strdup in string.h.
 */
#define _POSIX_C_SOURCE 200809L

#include <stddef.h>  /* NULL */
#include <string.h>  /* strdup */

/* C++ Abstract Syntax Interface.*/

/********************   TypeDef Section    ********************/

typedef int Integer;
typedef char Char;
typedef double Double;
typedef char* String;
typedef char* Ident;
typedef char* UVar;
typedef char* LVar;

/********************   Forward Declarations    ***********************/
struct Graph_;
typedef struct Graph_ *Graph;

struct Binding_;
typedef struct Binding_ *Binding;

struct GraphBinding_;
typedef struct GraphBinding_ *GraphBinding;

struct Vertex_;
typedef struct Vertex_ *Vertex;

struct Name_;
typedef struct Name_ *Name;

struct ListName_;
typedef struct ListName_ *ListName;

/********************   Abstract Syntax Classes    ********************/

struct Graph_
{
  enum { is_GNil, is_GVertex, is_GVar, is_GNominate, is_GEdgeAnon, is_GEdgeNamed, is_GRuleAnon, is_GRuleNamed, is_GSubgraph, is_GTensor } kind;
  union
  {
    struct { Graph graph_; Vertex vertex_; } gVertex_;
    struct { Graph graph_; LVar lvar_; } gVar_;
    struct { Binding binding_; } gNominate_;
    struct { Binding binding_1, binding_2; } gEdgeAnon_;
    struct { Binding binding_1, binding_2; Name name_; } gEdgeNamed_;
    struct { Graph graph_1, graph_2; } gRuleAnon_;
    struct { Graph graph_1, graph_2; Name name_; } gRuleNamed_;
    struct { GraphBinding graphbinding_; } gSubgraph_;
    struct { Graph graph_1, graph_2; } gTensor_;
  } u;
};

Graph make_GNil(void);
Graph make_GVertex(Vertex p0, Graph p1);
Graph make_GVar(LVar p0, Graph p1);
Graph make_GNominate(Binding p0);
Graph make_GEdgeAnon(Binding p0, Binding p1);
Graph make_GEdgeNamed(Name p0, Binding p1, Binding p2);
Graph make_GRuleAnon(Graph p0, Graph p1);
Graph make_GRuleNamed(Name p0, Graph p1, Graph p2);
Graph make_GSubgraph(GraphBinding p0);
Graph make_GTensor(Graph p0, Graph p1);

struct Binding_
{
  enum { is_VBind } kind;
  union
  {
    struct { Graph graph_; LVar lvar_; Vertex vertex_; } vBind_;
  } u;
};

Binding make_VBind(LVar p0, Vertex p1, Graph p2);

struct GraphBinding_
{
  enum { is_GBind } kind;
  union
  {
    struct { Graph graph_1, graph_2; UVar uvar_; } gBind_;
  } u;
};

GraphBinding make_GBind(UVar p0, Graph p1, Graph p2);

struct Vertex_
{
  enum { is_VName } kind;
  union
  {
    struct { Name name_; } vName_;
  } u;
};

Vertex make_VName(Name p0);

struct Name_
{
  enum { is_NameWildcard, is_NameVVar, is_NameGVar, is_NameQuoteGraph, is_NameQuoteVertex } kind;
  union
  {
    struct { LVar lvar_; } nameVVar_;
    struct { UVar uvar_; } nameGVar_;
    struct { Graph graph_; } nameQuoteGraph_;
    struct { Vertex vertex_; } nameQuoteVertex_;
  } u;
};

Name make_NameWildcard(void);
Name make_NameVVar(LVar p0);
Name make_NameGVar(UVar p0);
Name make_NameQuoteGraph(Graph p0);
Name make_NameQuoteVertex(Vertex p0);

struct ListName_
{
  Name name_;
  ListName listname_;
};

ListName make_ListName(Name p1, ListName p2);

/***************************   Cloning   ******************************/

Graph clone_Graph(Graph p);
Binding clone_Binding(Binding p);
GraphBinding clone_GraphBinding(GraphBinding p);
Vertex clone_Vertex(Vertex p);
Name clone_Name(Name p);
ListName clone_ListName(ListName p);

/********************   Recursive Destructors    **********************/

/* These free an entire abstract syntax tree
 * including all subtrees and strings.
 *
 * Will not work properly if there is sharing in the tree,
 * i.e., when some pointers are aliased.  In this case
 * it will attempt to free the same memory twice.
 */

void free_Graph(Graph p);
void free_Binding(Binding p);
void free_GraphBinding(GraphBinding p);
void free_Vertex(Vertex p);
void free_Name(Name p);
void free_ListName(ListName p);


#endif
